import os
import json
from typing import List
from litellm import completion

# ----- API Setup -----
import os
import litellm
litellm.api_key = os.getenv("OPENAI_API_KEY")
if not litellm.api_key:
    print("❌ Please set OPENAI_API_KEY")
    exit(1)

MODEL = "gpt-4o-mini"

"""First, we define the actual Python functions that will be executed. These contain the business logic for each tool and handle the actual operations the AI agent can perform."""

# 1. Define the function tool

# list files in the current directory
def list_files() -> List[str]:
    """List files in the current directory."""
    return os.listdir(".")

# read file 
def read_file(file_name: str) -> str:
    """Read a file's contents."""
    try:
        with open(file_name, "r") as file:
            return file.read()
    except FileNotFoundError:
        return f"Error: {file_name} not found."
    except Exception as e:
        return f"Error: {str(e)}"

# 2. Create a function registry
"""We maintain a dictionary that maps function names to their corresponding Python implementations. This registry allows us to easily look up and execute the appropriate function when the model calls it."""

tool_functions = {
    "list_files": list_files,
    "read_file": read_file
}

# 3. Define tool specification
"""This is where we describe our tools to the model. Each tool specification includes:

A name that matches a key in our tool_functions dictionary
A description that helps the model understand when to use this tool
Parameters defined using JSON Schema, specifying the expected input format
Note how the list_files function takes no parameters (empty “properties” object), while read_file requires a “file_name” string parameter. The model will use these specifications to generate properly structured calls."""

tools = [
    {
        "type": "function",
        "function": {
            "name": "list_files",
            "description": "Returns a list of files in the directory.",
            "parameters": {"type": "object", "properties": {}, "required": []}
        }
    },
    {
        "type": "function",
        "function": {
            "name": "read_file",
            "description": "Reads the content of a specified file in the directory.",
            "parameters": {
                "type": "object",
                "properties": {"file_name": {"type": "string"}},
                "required": ["file_name"]
            }
        }
    }
]

# 4. Set Up the Agent’s Instructions
"""The system message provides guidance on how the agent should behave. With function calling, we don’t need to instruct the model on how to format its outputs - we only need to focus on the decision-making logic."""

agent_rules = [{
    "role": "system",
    "content": """
You are an AI agent that can perform tasks by using available tools. 

If a user asks about files, documents, or content, first list the files before reading them.
"""
}]

# 5. Prepare the Conversation Context
"""We combine the system instructions with the user’s input to create the conversation context."""

user_task = input("What would you like me to do? ")
memory = [{"role": "user", "content": user_task}]
messages = agent_rules + memory

# 6. Make the API Call with Function Definitions
"""The critical difference here is the inclusion of the tools parameter, which tells the model what functions it can call. This is what activates the function calling mechanism."""

response = completion(
    model=MODEL,
    messages=messages,
    tools=tools,
    max_tokens=1024
)

# 7. Process the Structured Response
"""When using function calling, the response comes back with a dedicated tool_calls array rather than free-text output. This ensures that:

The function name is properly identified
The arguments are correctly formatted as valid JSON
We don’t need to parse or extract from unstructured text"""

tool = response.choices[0].message.tool_calls[0]
tool_name = tool.function.name
tool_args = json.loads(tool.function.arguments)

# 8. Execute the Function with the Provided Arguments
"""Finally, we look up the appropriate function in our registry and call it with the arguments the model provided. The **tool_args syntax unpacks the JSON object into keyword arguments."""

result = tool_functions[tool_name](**tool_args)

print(f"Tool Name: {tool_name}")
print(f"Tool Arguments: {tool_args}")
print(f"Result: {result}")

"""Key Benefits of Function Calling APIs

Eliminates prompt engineering for structured responses – No need to force the model to output JSON manually.
Uses standardized JSON Schema – The same format used in API documentation applies seamlessly to AI interactions.
Allows mixed text and tool execution – The model can decide whether a tool is necessary or provide a natural response.
Simplifies parsing logic – Instead of handling inconsistent outputs, developers only check for tool_calls in the response.
Guarantees syntactically correct arguments – The model automatically ensures arguments match the expected parameter format.
"""
